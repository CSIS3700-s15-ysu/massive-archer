//suggestions from Dr S:
void begin_explosion (float x, float y, bool hit) {
//create proper explosion type
//update world state

//first, find out where the shell hit


//did shell hit tank? (impact_location = tank_location)
	yes = display hit sprite at impact_location
	no = display miss sprite at impact_location

}

void end_explosion (explosion_sprite *) {
//remove explosion sprite
//update world state from IMPACT to AIMING or GAME_OVER }

//Annie's pseudocode

//math for the shell
float initial_shell_velocity (float velocity_from_user, float angle_from_user) {
	//rad_angle_from_user = angle_from_user * (pi/180)
	float initial_v_x, initial_v_y;
	initial_v_y = velocity_from_user * sin(rad_angle_from_user);
	initial_v_x = velocity_from_user * cos(rad_angle_from_user);
	
	return initial_v_x, initial_v_y;
	}
	
	
	//position after time step (t) is ((x(t + delta_t)), (y(t+ delta_t)))
	//x_position, y_position are intended to represent ((x(t + delta_t)), (y(t+ delta_t)))
	
float shell_velocity (float incoming_v_x, float incoming_v_y, float dt) {
	//initial shell velocity has already been computed
	//should also be able to call this whenever time updates
	
	float velocity_y, velocity_x;
	float accel_y = 300;
	//float accel_x = 0;
	
	//velocity of x won't change so not going to bother updating it	
	//velocity_x = velocity_x_at_t + (accel_x * dt)
	
	velocity_x = incoming_v_x;
	velocity_y = incoming_v_y + (accel_y * dt);

}
	
float shell_path (lots of stuff I'm sure) {


	
	velocity_x_at_t = initial_v_x;
	
	//first pass velocity_y_at_t will be initial_v_y
	//after that recursion may be a good idea -- splitting it
	//into another function will help with that
	

	velocity_x = velocity_x_at_t; 
	//velocity_x and velocity_x_at_t aren't going to change
	velocity_y = velocity_y_at_t + (accel_y * delta_t)
	
	//would we use a loop or recursion for this?
	//loop or recursion would end when y_position = HEIGHT * 0.75 (height of tanks)
	//we'll want to return the x_position
	x_position = x_position_at_t + (velocity_x_at_t * delta_t)
	y_position = y_position_at_t + (velocity_y_at_t * delta_t)

}	


}



void aim_angle (key event) {
	if key event = up then
		increase angle
		
	else
		decrease angle
		
	tell sprite to move
}

void aim_velocity (key event) {
	if key event = right then
		increase velocity
		
	else
		decrease velocity
		
	tell sprite to move
}

